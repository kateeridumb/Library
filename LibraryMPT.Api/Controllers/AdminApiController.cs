using LibraryMPT.Data;using LibraryMPT.Api.Extensions;using LibraryMPT.Models;using Microsoft.AspNetCore.Authorization;using Microsoft.AspNetCore.Mvc;using Npgsql;using Microsoft.EntityFrameworkCore;using System.Diagnostics;using System.Security.Cryptography;using System.Text;using System.Text.RegularExpressions;namespace LibraryMPT.Api.Controllers;[ApiController][Authorize(Roles = "Admin")][Route("api/admin")]public sealed class AdminApiController : ControllerBase{    private readonly LibraryContext _context;    public AdminApiController(LibraryContext context)    {        _context = context;    }    [HttpGet("security-dashboard")]    public async Task<ActionResult<AdminSecurityDashboardResponse>> SecurityDashboard()    {        var result = new AdminSecurityDashboardResponse        {            TotalUsers = await _context.Database.SqlQuery<int>($"SELECT COUNT(*) AS \"Value\" FROM \"Users\"").SingleAsync(),            TotalBooks = await _context.Database.SqlQuery<int>($"SELECT COUNT(*) AS \"Value\" FROM \"Books\"").SingleAsync(),            DownloadsLast24h = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value"" FROM ""BookLogs""                WHERE actiontype = 'DOWNLOAD' AND actionat >= NOW() - INTERVAL '1 day'            """).SingleAsync(),            ReadsLast24h = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value"" FROM ""BookLogs""                WHERE actiontype = 'READ' AND actionat >= NOW() - INTERVAL '1 day'            """).SingleAsync(),            AuditEventsLast24h = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value"" FROM ""AuditLog""                WHERE auditdate >= NOW() - INTERVAL '1 day'            """).SingleAsync(),            BlockedUsers = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value"" FROM ""Users"" WHERE ""IsBlocked"" = TRUE            """).SingleAsync(),            TwoFactorUsers = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value"" FROM ""Users"" WHERE ""IsTwoFactorEnabled"" = TRUE            """).SingleAsync(),            TwoFactorStudents = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value""                FROM ""Users"" u JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""                WHERE u.istwofactorenabled = TRUE AND r.rolename = 'Student'            """).SingleAsync(),            ActiveSubscriptions = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value""                FROM subscriptions                WHERE facultyid IS NOT NULL                  AND (status = 'Approved' OR status IS NULL)                  AND startdate IS NOT NULL                  AND enddate IS NOT NULL                  AND NOW() BETWEEN startdate AND enddate            """).SingleAsync(),            PendingSubscriptions = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value"" FROM ""Subscriptions"" WHERE ""Status"" = 'Pending'            """).SingleAsync(),            BooksRequiringSubscription = await _context.Database.SqlQuery<int>($"""                SELECT COUNT(*) AS ""Value"" FROM ""Books"" WHERE ""RequiresSubscription"" = TRUE            """).SingleAsync(),            DbSizeMb = await _context.Database.SqlQuery<int>($"""                SELECT ROUND(pg_database_size(current_database()) / 1024.0 / 1024.0)::int AS ""Value""            """).SingleAsync()        };        result.LastAudit = await _context.AuditLog            .FromSqlRaw("""                SELECT auditlogid AS ""AuditLogID"", tablename AS ""TableName"", actiontype AS ""ActionType"", recordid AS ""RecordID"", username AS ""UserName"", olddata AS ""OldData"", newdata AS ""NewData"", auditdate AS ""AuditDate"" FROM ""AuditLog"" ORDER BY auditdate DESC LIMIT 10            """)            .AsNoTracking()            .ToListAsync();        result.AuditPopular = await _context.AuditSummaries            .FromSqlRaw("""                SELECT tablename AS ""TableName"", actiontype AS ""ActionType"", COUNT(*) AS ""EventsCount""                FROM ""AuditLog""                WHERE auditdate >= NOW() - INTERVAL '1 day'                GROUP BY tablename, actiontype                ORDER BY COUNT(*) DESC                LIMIT 7            """)            .AsNoTracking()            .ToListAsync();        return Ok(result);    }    [HttpGet("user-management")]    public async Task<ActionResult<AdminUserManagementResponse>> UserManagement(        [FromQuery] string? search,        [FromQuery] string? roleFilter,        [FromQuery] string? facultyFilter,        [FromQuery] string? statusFilter)    {        var sql = @"            SELECT                u.userid AS ""UserID"",                u.email AS ""Email"",                u.roleid AS ""RoleID"",                u.facultyid AS ""FacultyID"",                r.rolename AS ""RoleName"",                f.facultyname AS ""FacultyName"",                u.isblocked AS ""IsBlocked""            FROM ""Users"" u            JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""            LEFT JOIN ""Faculty"" f ON f.""FacultyID"" = u.""FacultyID""            WHERE                (@search IS NULL OR u.email ILIKE '%' || @search || '%')                AND (@roleFilter IS NULL OR r.rolename = @roleFilter)                AND (@facultyFilter IS NULL OR f.facultyname = @facultyFilter)                AND (@statusFilter IS NULL OR                    (@statusFilter = 'active' AND u.isblocked = FALSE) OR                    (@statusFilter = 'blocked' AND u.isblocked = TRUE))            ORDER BY u.userid";        var users = await _context.Set<UserAdminDto>()            .FromSqlRaw(sql,                new NpgsqlParameter("@search", NpgsqlTypes.NpgsqlDbType.Text) { Value = (object?)search ?? DBNull.Value },                new NpgsqlParameter("@roleFilter", NpgsqlTypes.NpgsqlDbType.Text) { Value = (object?)roleFilter ?? DBNull.Value },                new NpgsqlParameter("@facultyFilter", NpgsqlTypes.NpgsqlDbType.Text) { Value = (object?)facultyFilter ?? DBNull.Value },                new NpgsqlParameter("@statusFilter", NpgsqlTypes.NpgsqlDbType.Text) { Value = (object?)statusFilter ?? DBNull.Value })            .AsNoTracking()            .ToListAsync();        var roles = await _context.Roles.FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\"").AsNoTracking().ToListAsync();        var faculties = await _context.Faculty.FromSqlRaw("SELECT facultyid AS \"FacultyID\", facultyname AS \"FacultyName\" FROM \"Faculty\"").AsNoTracking().ToListAsync();        return Ok(new AdminUserManagementResponse        {            Search = search,            RoleFilter = roleFilter,            FacultyFilter = facultyFilter,            StatusFilter = statusFilter,            Roles = roles,            Faculties = faculties,            Users = users        });    }    [HttpGet("decrypt-last-name/{userId:int}")]    public async Task<ActionResult<DecryptLastNameResponse>> DecryptLastName(int userId)    {        try        {            string? decryptedLastName;            var connection = _context.Database.GetDbConnection();            await connection.OpenAsync();            try            {                using var command = connection.CreateCommand();                command.CommandText = """                    SELECT convert_from(lastname, 'UTF8') AS DecryptedLastName                    FROM ""Users""                    WHERE ""UserID"" = @userId;                """;                command.Parameters.Add(new NpgsqlParameter("@userId", userId));                var result = await command.ExecuteScalarAsync();                decryptedLastName = result?.ToString();            }            finally            {                await connection.CloseAsync();            }            return Ok(new DecryptLastNameResponse            {                Success = true,                LastName = decryptedLastName ?? "Не удалось расшифровать"            });        }        catch (Exception ex)        {            return Ok(new DecryptLastNameResponse            {                Success = false,                Error = ex.Message            });        }    }    [HttpGet("role-assignment")]    public async Task<ActionResult<AdminRoleAssignmentResponse>> RoleAssignment()    {        var users = await _context.Set<UserAdminDto>()            .FromSqlRaw("""                SELECT                    u.userid AS ""UserID"",                    u.email AS ""Email"",                    u.roleid AS ""RoleID"",                    r.rolename AS ""RoleName"",                    u.facultyid AS ""FacultyID"",                    f.facultyname AS ""FacultyName"",                    u.isblocked AS ""IsBlocked""                FROM ""Users"" u                JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""                LEFT JOIN ""Faculty"" f ON f.""FacultyID"" = u.""FacultyID""            """)            .AsNoTracking()            .ToListAsync();        var roles = await _context.Roles.FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\"").AsNoTracking().ToListAsync();        return Ok(new AdminRoleAssignmentResponse { Users = users, Roles = roles });    }    [HttpGet("audit-log")]    public async Task<ActionResult<AdminAuditLogResponse>> AuditLog(        [FromQuery] string? actionType,        [FromQuery] string? search,        [FromQuery] string? sortBy,        [FromQuery] string? sortDir)    {        var normalizedSortBy = (sortBy ?? "date").Trim().ToLowerInvariant();        var normalizedSortDir = (sortDir ?? "desc").Trim().ToLowerInvariant() == "asc" ? "ASC" : "DESC";        var orderColumn = normalizedSortBy switch        {            "table" => "TableName",            "action" => "ActionType",            "user" => "UserName",            _ => "AuditDate"        };        var orderColumnLower = orderColumn.ToLowerInvariant();var orderClause = orderColumnLower == "auditdate"? $"auditdate {normalizedSortDir}": $"{orderColumnLower} {normalizedSortDir}, auditdate DESC";        var sql = $"""            SELECT auditlogid AS ""AuditLogID"", tablename AS ""TableName"", actiontype AS ""ActionType"", recordid AS ""RecordID"", username AS ""UserName"", olddata AS ""OldData"", newdata AS ""NewData"", auditdate AS ""AuditDate"" FROM ""AuditLog""            WHERE (@action IS NULL OR actiontype = @action)              AND (@search IS NULL                   OR tablename ILIKE '%' || @search || '%'                   OR actiontype ILIKE '%' || @search || '%'                   OR username ILIKE '%' || @search || '%'                   OR olddata ILIKE '%' || @search || '%'                   OR newdata ILIKE '%' || @search || '%')            ORDER BY {orderClause}            LIMIT 300        """;        var logs = await _context.AuditLog            .FromSqlRaw(sql,                new NpgsqlParameter("@action", (object?)actionType ?? DBNull.Value),                new NpgsqlParameter("@search", (object?)search ?? DBNull.Value))            .AsNoTracking()            .ToListAsync();        return Ok(new AdminAuditLogResponse        {            ActionType = actionType,            Search = search,            SortBy = normalizedSortBy,            SortDir = normalizedSortDir.ToLowerInvariant(),            Logs = logs        });    }    [HttpGet("faculties")]    public async Task<ActionResult<List<Faculty>>> Faculties([FromQuery] string? search)    {        var sql = @"            SELECT facultyid AS ""FacultyID"", facultyname AS ""FacultyName""            FROM ""Faculty""            WHERE (@search IS NULL OR facultyname ILIKE '%' || @search || '%')            ORDER BY facultyname";        var faculties = await _context.Faculty            .FromSqlRaw(sql, new NpgsqlParameter("@search", (object?)search ?? DBNull.Value))            .AsNoTracking()            .ToListAsync();        return Ok(faculties);    }    [HttpGet("faculties/{id:int}")]    public async Task<ActionResult<Faculty>> FacultyById(int id)    {        var faculty = await _context.Faculty            .FromSqlRaw("SELECT facultyid AS \"FacultyID\", facultyname AS \"FacultyName\" FROM \"Faculty\" WHERE facultyid = @id", new NpgsqlParameter("@id", id))            .AsNoTracking()            .FirstOrDefaultAsync();        return faculty is null ? NotFound() : Ok(faculty);    }    [HttpPost("faculties")]    public async Task<ActionResult<ApiCommandResponse>> AddFaculty([FromBody] Faculty faculty)    {        var exists = await _context.Faculty            .FromSqlRaw("SELECT facultyid AS \"FacultyID\", facultyname AS \"FacultyName\" FROM \"Faculty\" WHERE facultyname = @name", new NpgsqlParameter("@name", faculty.FacultyName.Trim()))            .AnyAsync();        if (exists)        {            return Ok(new ApiCommandResponse { Success = false, Message = "Факультет с таким названием уже существует." });        }        await _context.Database.ExecuteSqlRawAsync(            "INSERT INTO faculty (facultyname) VALUES (@name)",            new NpgsqlParameter("@name", faculty.FacultyName.Trim()));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpPut("faculties/{id:int}")]    public async Task<ActionResult<ApiCommandResponse>> EditFaculty(int id, [FromBody] Faculty faculty)    {        if (id != faculty.FacultyID)        {            return BadRequest(new ApiCommandResponse { Success = false, Message = "Faculty id mismatch." });        }        var exists = await _context.Faculty            .FromSqlRaw("SELECT facultyid AS \"FacultyID\", facultyname AS \"FacultyName\" FROM \"Faculty\" WHERE facultyname = @name AND facultyid != @id",                new NpgsqlParameter("@name", faculty.FacultyName.Trim()),                new NpgsqlParameter("@id", faculty.FacultyID))            .AnyAsync();        if (exists)        {            return Ok(new ApiCommandResponse { Success = false, Message = "Факультет с таким названием уже существует." });        }        await _context.Database.ExecuteSqlRawAsync(            "UPDATE faculty SET facultyname = @name WHERE facultyid = @id",            new NpgsqlParameter("@name", faculty.FacultyName.Trim()),            new NpgsqlParameter("@id", faculty.FacultyID));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpDelete("faculties/{id:int}")]    public async Task<ActionResult<ApiCommandResponse>> DeleteFaculty(int id)    {        await _context.Database.ExecuteSqlRawAsync(            "DELETE FROM \"Faculty\" WHERE facultyid = @id",            new NpgsqlParameter("@id", id));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpGet("roles")]    public async Task<ActionResult<List<Role>>> Roles([FromQuery] string? search)    {        var sql = @"            SELECT roleid AS ""RoleID"", rolename AS ""RoleName""            FROM ""Roles""            WHERE (@search IS NULL OR rolename ILIKE '%' || @search || '%')            ORDER BY rolename";        var roles = await _context.Roles            .FromSqlRaw(sql, new NpgsqlParameter("@search", (object?)search ?? DBNull.Value))            .AsNoTracking()            .ToListAsync();        return Ok(roles);    }    [HttpGet("roles/{id:int}")]    public async Task<ActionResult<Role>> RoleById(int id)    {        var role = await _context.Roles            .FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\" WHERE roleid = @id", new NpgsqlParameter("@id", id))            .AsNoTracking()            .FirstOrDefaultAsync();        return role is null ? NotFound() : Ok(role);    }    [HttpPost("roles")]    public async Task<ActionResult<ApiCommandResponse>> AddRole([FromBody] Role role)    {        var exists = await _context.Roles            .FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\" WHERE rolename = @name", new NpgsqlParameter("@name", role.RoleName.Trim()))            .AnyAsync();        if (exists)        {            return Ok(new ApiCommandResponse { Success = false, Message = "Роль с таким названием уже существует." });        }        await _context.Database.ExecuteSqlRawAsync(            "INSERT INTO \"Roles\" (\"RoleName\") VALUES (@name)",            new NpgsqlParameter("@name", role.RoleName.Trim()));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpPut("roles/{id:int}")]    public async Task<ActionResult<ApiCommandResponse>> EditRole(int id, [FromBody] Role role)    {        if (id != role.RoleID)        {            return BadRequest(new ApiCommandResponse { Success = false, Message = "Role id mismatch." });        }        var exists = await _context.Roles            .FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\" WHERE rolename = @name AND roleid != @id",                new NpgsqlParameter("@name", role.RoleName.Trim()),                new NpgsqlParameter("@id", role.RoleID))            .AnyAsync();        if (exists)        {            return Ok(new ApiCommandResponse { Success = false, Message = "Роль с таким названием уже существует." });        }        await _context.Database.ExecuteSqlRawAsync(            "UPDATE \"Roles\" SET \"RoleName\" = @name WHERE roleid = @id",            new NpgsqlParameter("@name", role.RoleName.Trim()),            new NpgsqlParameter("@id", role.RoleID));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpDelete("roles/{id:int}")]    public async Task<ActionResult<ApiCommandResponse>> DeleteRole(int id)    {        var usersCount = await _context.Database            .SqlQuery<int>($"SELECT COUNT(*) AS \"Value\" FROM \"Users\" WHERE roleid = {id}")            .SingleAsync();        if (usersCount > 0)        {            return Ok(new ApiCommandResponse            {                Success = false,                Message = $"Невозможно удалить роль: используется у {usersCount} пользователей."            });        }        await _context.Database.ExecuteSqlRawAsync(            "DELETE FROM \"Roles\" WHERE \"RoleID\" = @id",            new NpgsqlParameter("@id", id));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpGet("roles/{id:int}/users-count")]    public async Task<ActionResult<int>> RoleUsersCount(int id)    {        var usersCount = await _context.Database            .SqlQuery<int>($"SELECT COUNT(*) AS \"Value\" FROM \"Users\" WHERE roleid = {id}")            .SingleAsync();        return Ok(usersCount);    }    [HttpPost("users/{id:int}/toggle-block")]    public async Task<ActionResult<ApiCommandResponse>> ToggleBlock(int id)    {        await _context.Database.ExecuteSqlRawAsync("""            UPDATE ""Users""            SET isblocked = CASE WHEN isblocked THEN FALSE ELSE TRUE END            WHERE userid = @id        """, new NpgsqlParameter("@id", id));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpDelete("users/{id:int}")]    public async Task<ActionResult<ApiCommandResponse>> DeleteUser(int id)    {        var user = await _context.Set<UserAdminDto>()            .FromSqlRaw("""                SELECT                    u.userid AS ""UserID"",                    u.email AS ""Email"",                    u.roleid AS ""RoleID"",                    u.facultyid AS ""FacultyID"",                    r.rolename AS ""RoleName"",                    f.facultyname AS ""FacultyName"",                    u.isblocked AS ""IsBlocked""                FROM ""Users"" u                JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""                LEFT JOIN ""Faculty"" f ON f.""FacultyID"" = u.""FacultyID""                WHERE u.userid = @id            """, new NpgsqlParameter("@id", id))            .AsNoTracking()            .FirstOrDefaultAsync();        if (user == null)        {            return NotFound(new ApiCommandResponse { Success = false, Message = "Пользователь не найден." });        }        if (user.RoleName == "Admin")        {            return Ok(new ApiCommandResponse { Success = false, Message = "Нельзя удалить администратора." });        }        await _context.Database.ExecuteSqlRawAsync(            "DELETE FROM \"Users\" WHERE \"UserID\" = @id",            new NpgsqlParameter("@id", id));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpPost("users/update-role")]    public async Task<ActionResult<ApiCommandResponse>> UpdateUserRole([FromBody] UpdateUserRoleRequest request)    {        if (request.UserId <= 0)            return Ok(new ApiCommandResponse { Success = false, Message = "Некорректный ID пользователя." });        if (request.RoleId <= 0)            return Ok(new ApiCommandResponse { Success = false, Message = "Некорректный ID роли." });        var user = await _context.Set<UserAdminDto>()            .FromSqlRaw("""                SELECT                    u.userid AS ""UserID"",                    u.email AS ""Email"",                    u.roleid AS ""RoleID"",                    u.facultyid AS ""FacultyID"",                    r.rolename AS ""RoleName"",                    f.facultyname AS ""FacultyName"",                    u.isblocked AS ""IsBlocked""                FROM ""Users"" u                JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""                LEFT JOIN ""Faculty"" f ON f.""FacultyID"" = u.""FacultyID""                WHERE u.userid = @userId            """, new NpgsqlParameter("@userId", request.UserId))            .AsNoTracking()            .FirstOrDefaultAsync();        if (user == null)            return Ok(new ApiCommandResponse { Success = false, Message = "Пользователь не найден." });        var role = await _context.Roles            .FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\" WHERE roleid = @roleId", new NpgsqlParameter("@roleId", request.RoleId))            .AsNoTracking()            .FirstOrDefaultAsync();        if (role == null)            return Ok(new ApiCommandResponse { Success = false, Message = "Роль не найдена." });        var rowsAffected = await _context.Database.ExecuteSqlRawAsync("""            UPDATE ""Users""            SET roleid = @roleId            WHERE userid = @userId        """,            new NpgsqlParameter("@roleId", request.RoleId),            new NpgsqlParameter("@userId", request.UserId));        return Ok(new ApiCommandResponse        {            Success = rowsAffected > 0,            Message = rowsAffected > 0 ? "Роль пользователя успешно обновлена." : "Не удалось обновить роль пользователя."        });    }    [HttpPost("clear-audit-logs")]    public async Task<ActionResult<ApiCommandResponse>> ClearAuditLogs()    {        await _context.Database.ExecuteSqlRawAsync("DELETE FROM \"AuditLog\"");        return Ok(new ApiCommandResponse { Success = true });    }    [HttpGet("backups")]    public ActionResult<AdminBackupResponse> Backups()    {        var backupDir = GetSqlServerBackupPath();        var backupFiles = new List<BackupFileDto>();        if (Directory.Exists(backupDir))        {            foreach (var file in Directory.GetFiles(backupDir, "LibraryMPT_*.dump"))            {                var info = new FileInfo(file);                backupFiles.Add(new BackupFileDto                {                    Name = info.Name,                    Date = info.LastWriteTime,                    Size = info.Length                });            }        }        return Ok(new AdminBackupResponse        {            BackupDir = backupDir,            BackupFiles = backupFiles.OrderByDescending(x => x.Date).ToList()        });    }    [HttpPost("backups/create")]    public async Task<ActionResult<ApiCommandResponse>> CreateBackup()    {        try        {            var backupDir = GetSqlServerBackupPath();            var timestamp = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");            var fileName = $"LibraryMPT_Backup_{timestamp}.dump";            var backupPath = Path.Combine(backupDir, fileName);            var cs = new NpgsqlConnectionStringBuilder(_context.Database.GetConnectionString() ?? string.Empty);            var host = string.IsNullOrWhiteSpace(cs.Host) ? "localhost" : cs.Host;            var username = string.IsNullOrWhiteSpace(cs.Username) ? "postgres" : cs.Username;            var database = string.IsNullOrWhiteSpace(cs.Database) ? "postgres" : cs.Database;            var process = new ProcessStartInfo            {                FileName = "pg_dump",                UseShellExecute = false,                RedirectStandardOutput = true,                RedirectStandardError = true,                CreateNoWindow = true            };            process.ArgumentList.Add("--host");            process.ArgumentList.Add(host);            process.ArgumentList.Add("--port");            process.ArgumentList.Add(cs.Port.ToString());            process.ArgumentList.Add("--username");            process.ArgumentList.Add(username);            process.ArgumentList.Add("--format");            process.ArgumentList.Add("custom");            process.ArgumentList.Add("--file");            process.ArgumentList.Add(backupPath);            process.ArgumentList.Add(database);            process.Environment["PGPASSWORD"] = cs.Password ?? string.Empty;            using var proc = Process.Start(process);            if (proc == null)                return Ok(new ApiCommandResponse { Success = false, Message = "Не удалось запустить pg_dump." });            var stderr = await proc.StandardError.ReadToEndAsync();            await proc.WaitForExitAsync();            if (proc.ExitCode != 0)            {                return Ok(new ApiCommandResponse                {                    Success = false,                    Message = $"pg_dump завершился с ошибкой ({proc.ExitCode}): {stderr}"                });            }            return Ok(new ApiCommandResponse            {                Success = true,                Message = $"Резервная копия создана: {fileName}"            });        }        catch (Exception ex)        {            return Ok(new ApiCommandResponse { Success = false, Message = ex.Message });        }    }    [HttpGet("backups/download")]    public IActionResult DownloadBackup([FromQuery] string fileName)    {        if (string.IsNullOrWhiteSpace(fileName))            return NotFound();        var filePath = Path.Combine(GetSqlServerBackupPath(), fileName);        if (!System.IO.File.Exists(filePath))            return NotFound();        return PhysicalFile(filePath, "application/octet-stream", fileName);    }    [HttpDelete("backups")]    public ActionResult<ApiCommandResponse> DeleteBackup([FromQuery] string fileName)    {        if (string.IsNullOrWhiteSpace(fileName))            return Ok(new ApiCommandResponse { Success = false, Message = "Имя файла не указано" });        var filePath = Path.Combine(GetSqlServerBackupPath(), fileName);        if (System.IO.File.Exists(filePath))        {            System.IO.File.Delete(filePath);            return Ok(new ApiCommandResponse { Success = true, Message = $"Файл {fileName} удален" });        }        return Ok(new ApiCommandResponse { Success = false, Message = "Файл не найден" });    }    [HttpPost("backups/restore")]    public async Task<ActionResult<ApiCommandResponse>> RestoreBackup([FromQuery] string fileName)    {        if (string.IsNullOrWhiteSpace(fileName))            return Ok(new ApiCommandResponse { Success = false, Message = "Имя файла не указано" });        var filePath = Path.Combine(GetSqlServerBackupPath(), fileName);        if (!System.IO.File.Exists(filePath))            return Ok(new ApiCommandResponse { Success = false, Message = "Файл бэкапа не найден" });        try        {            var cs = new NpgsqlConnectionStringBuilder(_context.Database.GetConnectionString() ?? string.Empty);            var host = string.IsNullOrWhiteSpace(cs.Host) ? "localhost" : cs.Host;            var username = string.IsNullOrWhiteSpace(cs.Username) ? "postgres" : cs.Username;            var database = string.IsNullOrWhiteSpace(cs.Database) ? "postgres" : cs.Database;            var adminCs = new NpgsqlConnectionStringBuilder(cs.ConnectionString)            {                Database = "postgres"            };            await using (var conn = new NpgsqlConnection(adminCs.ConnectionString))            {                await conn.OpenAsync();                await using var terminateCmd = new NpgsqlCommand("""                    SELECT pg_terminate_backend(pid)                    FROM pg_stat_activity                    WHERE datname = @db                      AND pid <> pg_backend_pid();                """, conn);                terminateCmd.Parameters.AddWithValue("@db", database);                await terminateCmd.ExecuteNonQueryAsync();            }            var process = new ProcessStartInfo            {                FileName = "pg_restore",                UseShellExecute = false,                RedirectStandardOutput = true,                RedirectStandardError = true,                CreateNoWindow = true            };            process.ArgumentList.Add("--host");            process.ArgumentList.Add(host);            process.ArgumentList.Add("--port");            process.ArgumentList.Add(cs.Port.ToString());            process.ArgumentList.Add("--username");            process.ArgumentList.Add(username);            process.ArgumentList.Add("--clean");            process.ArgumentList.Add("--if-exists");            process.ArgumentList.Add("--no-owner");            process.ArgumentList.Add("--dbname");            process.ArgumentList.Add(database);            process.ArgumentList.Add(filePath);            process.Environment["PGPASSWORD"] = cs.Password ?? string.Empty;            using var proc = Process.Start(process);            if (proc == null)                return Ok(new ApiCommandResponse { Success = false, Message = "Не удалось запустить pg_restore." });            var stderr = await proc.StandardError.ReadToEndAsync();            await proc.WaitForExitAsync();            if (proc.ExitCode != 0)            {                return Ok(new ApiCommandResponse                {                    Success = false,                    Message = $"pg_restore завершился с ошибкой ({proc.ExitCode}): {stderr}"                });            }            return Ok(new ApiCommandResponse { Success = true, Message = $"База восстановлена из {fileName}" });        }        catch (Exception ex)        {            return Ok(new ApiCommandResponse { Success = false, Message = ex.Message });        }    }    [HttpGet("create-user-lookups")]    public async Task<ActionResult<CreateUserLookupsResponse>> CreateUserLookups()    {        var roles = await _context.Roles.FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\"").AsNoTracking().ToListAsync();        var faculties = await _context.Faculty.FromSqlRaw("SELECT facultyid AS \"FacultyID\", facultyname AS \"FacultyName\" FROM \"Faculty\"").AsNoTracking().ToListAsync();        return Ok(new CreateUserLookupsResponse { Roles = roles, Faculties = faculties });    }    [HttpPost("users")]    public async Task<ActionResult<ApiCommandResponse>> CreateUser([FromBody] User user)    {        await _context.Database.ExecuteSqlRawAsync(@"            INSERT INTO ""Users"" (email, passwordhash, roleid, facultyid)            VALUES (@email, @password, @roleId, @facultyId)",            new NpgsqlParameter("@email", user.Email),            new NpgsqlParameter("@password", user.PasswordHash),            new NpgsqlParameter("@roleId", user.RoleID),            new NpgsqlParameter("@facultyId", (object?)user.FacultyID ?? DBNull.Value));        return Ok(new ApiCommandResponse { Success = true });    }    [HttpGet("users/{id:int}/edit")]    public async Task<ActionResult<EditUserViewResponse>> EditUserData(int id)    {        var currentUserId = User.GetUserId();        var user = await _context.Set<UserAdminDto>()            .FromSqlRaw("""                SELECT                    u.userid AS ""UserID"", u.email AS ""Email"", u.roleid AS ""RoleID"", r.rolename AS ""RoleName"", u.facultyid AS ""FacultyID"", f.facultyname AS ""FacultyName"", u.isblocked AS ""IsBlocked""                FROM ""Users"" u                JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""                LEFT JOIN ""Faculty"" f ON f.""FacultyID"" = u.""FacultyID""                WHERE u.userid = @id            """, new NpgsqlParameter("@id", id))            .AsNoTracking()            .FirstOrDefaultAsync();        if (user == null)            return NotFound();        var decrypted = await TryDecryptLastNameAsync(id);        var roles = await _context.Roles.FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\"").AsNoTracking().ToListAsync();        var faculties = await _context.Faculty.FromSqlRaw("SELECT facultyid AS \"FacultyID\", facultyname AS \"FacultyName\" FROM \"Faculty\"").AsNoTracking().ToListAsync();        var isEditingSelf = currentUserId == id;        var isAdminOrLibrarian = user.RoleName == "Admin" || user.RoleName == "Librarian";        var canEditFaculty = !(isEditingSelf && isAdminOrLibrarian) && user.RoleName != "Admin" && user.RoleName != "Librarian";        return Ok(new EditUserViewResponse        {            User = user,            DecryptedLastName = decrypted ?? "Не удалось расшифровать",            Roles = roles,            Faculties = faculties,            CanEditFaculty = canEditFaculty        });    }    [HttpPut("users/{id:int}")]    public async Task<ActionResult<ApiCommandResponse>> EditUser(int id, [FromBody] UpdateUserRequest request)    {        var dto = request.Dto;        if (id != dto.UserID)            return BadRequest(new ApiCommandResponse { Success = false, Message = "User id mismatch." });        var currentUser = await _context.Set<UserAdminDto>()            .FromSqlRaw("""                SELECT                    u.userid AS ""UserID"", u.email AS ""Email"", u.roleid AS ""RoleID"", r.rolename AS ""RoleName"", u.facultyid AS ""FacultyID"", f.facultyname AS ""FacultyName"", u.isblocked AS ""IsBlocked""                FROM ""Users"" u                JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""                LEFT JOIN ""Faculty"" f ON f.""FacultyID"" = u.""FacultyID""                WHERE u.userid = @id            """, new NpgsqlParameter("@id", dto.UserID))            .AsNoTracking()            .FirstOrDefaultAsync();        if (currentUser == null)            return Ok(new ApiCommandResponse { Success = false, Message = "Пользователь не найден." });        var isEditingSelf = User.GetUserId() == dto.UserID;        var isAdminOrLibrarian = currentUser.RoleName == "Admin" || currentUser.RoleName == "Librarian";        if (isEditingSelf && isAdminOrLibrarian)            dto.FacultyID = null;        if (string.IsNullOrWhiteSpace(dto.Email) || !Regex.IsMatch(dto.Email, @"^[^@\s]+@[^@\s]+\.[^@\s]+$"))            return Ok(new ApiCommandResponse { Success = false, Message = "Некорректный email." });        if (dto.RoleID <= 0)            return Ok(new ApiCommandResponse { Success = false, Message = "Выберите роль." });        var roleExists = await _context.Roles            .FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\" WHERE roleid = @roleId", new NpgsqlParameter("@roleId", dto.RoleID))            .AsNoTracking()            .AnyAsync();        if (!roleExists)            return Ok(new ApiCommandResponse { Success = false, Message = "Выбранная роль не существует." });        var emailExists = await _context.Set<UserAdminDto>()            .FromSqlRaw("""                SELECT u.userid AS ""UserID"", u.email AS ""Email"", u.roleid AS ""RoleID"", u.facultyid AS ""FacultyID"", r.rolename AS ""RoleName"", f.facultyname AS ""FacultyName"", u.isblocked AS ""IsBlocked""                FROM ""Users"" u                JOIN ""Roles"" r ON r.""RoleID"" = u.""RoleID""                LEFT JOIN ""Faculty"" f ON f.""FacultyID"" = u.""FacultyID""                WHERE u.email = @email AND u.userid != @userId            """,                new NpgsqlParameter("@email", dto.Email.Trim()),                new NpgsqlParameter("@userId", dto.UserID))            .AsNoTracking()            .AnyAsync();        if (emailExists)            return Ok(new ApiCommandResponse { Success = false, Message = "Пользователь с таким email уже существует." });        string updateSql;        var parameters = new List<NpgsqlParameter>        {            new("@em", dto.Email.Trim()),            new("@roleId", dto.RoleID),            new("@id", dto.UserID)        };        if (isEditingSelf && isAdminOrLibrarian)        {            updateSql = """                UPDATE ""Users""                SET email = @em, roleid = @roleId, facultyid = NULL                WHERE userid = @id            """;        }        else if (dto.FacultyID.HasValue && dto.FacultyID.Value > 0 && currentUser.RoleName != "Admin" && currentUser.RoleName != "Librarian")        {            updateSql = """                UPDATE ""Users""                SET email = @em, roleid = @roleId, facultyid = @facultyId                WHERE userid = @id            """;            parameters.Add(new NpgsqlParameter("@facultyId", dto.FacultyID.Value));        }        else        {            updateSql = """                UPDATE ""Users""                SET email = @em, roleid = @roleId, facultyid = NULL                WHERE userid = @id            """;        }        var rowsAffected = await _context.Database.ExecuteSqlRawAsync(updateSql, parameters.ToArray());        return Ok(new ApiCommandResponse        {            Success = rowsAffected > 0,            Message = rowsAffected > 0 ? $"Пользователь обновлен. Изменено строк: {rowsAffected}" : "Не удалось обновить пользователя."        });    }    [HttpGet("create-staff-lookups")]    public async Task<ActionResult<CreateUserLookupsResponse>> CreateStaffLookups()    {        var roles = await _context.Roles            .FromSqlRaw("""                SELECT roleid AS ""RoleID"", rolename AS ""RoleName"" FROM ""Roles"" WHERE rolename IN ('Admin', 'Librarian', 'InstitutionRepresentative')            """)            .AsNoTracking()            .ToListAsync();        var faculties = await _context.Faculty.FromSqlRaw("SELECT facultyid AS \"FacultyID\", facultyname AS \"FacultyName\" FROM \"Faculty\"").AsNoTracking().ToListAsync();        return Ok(new CreateUserLookupsResponse { Roles = roles, Faculties = faculties });    }    [HttpPost("staff")]    public async Task<ActionResult<CreateStaffResult>> CreateStaff([FromBody] CreateStaffRequest request)    {        var dto = request.Dto;        var selectedRole = await _context.Roles            .FromSqlRaw("SELECT roleid AS \"RoleID\", rolename AS \"RoleName\" FROM \"Roles\" WHERE roleid = @roleId", new NpgsqlParameter("@roleId", dto.RoleID))            .AsNoTracking()            .FirstOrDefaultAsync();        if (selectedRole != null && selectedRole.RoleName == "InstitutionRepresentative" && !dto.FacultyID.HasValue)            return Ok(new CreateStaffResult { Success = false, Message = "Для представителя учреждения нужен факультет." });        if (selectedRole != null && (selectedRole.RoleName == "Admin" || selectedRole.RoleName == "Librarian"))            dto.FacultyID = null;        var generatedPassword = GenerateSecurePassword();        CreatePasswordHash(generatedPassword, out var hash, out var salt);        await _context.Database.ExecuteSqlRawAsync("""            INSERT INTO ""Users""            (username, passwordhash, passwordsalt, firstname, lastname, email, roleid, facultyid)            VALUES            (                @un, @ph, @ps, @fn, @ln, @em, @role, @facultyId            );        """,            new NpgsqlParameter("@un", dto.Username),            new NpgsqlParameter("@ph", hash),            new NpgsqlParameter("@ps", salt),            new NpgsqlParameter("@fn", dto.FirstName),            new NpgsqlParameter("@ln", Encoding.UTF8.GetBytes(dto.LastName ?? string.Empty)),            new NpgsqlParameter("@em", dto.Email),            new NpgsqlParameter("@role", dto.RoleID),            new NpgsqlParameter("@facultyId", (object?)dto.FacultyID ?? DBNull.Value));        return Ok(new CreateStaffResult        {            Success = true,            GeneratedPassword = generatedPassword,            RoleName = selectedRole?.RoleName ?? "Сотрудник"        });    }    private async Task<string?> TryDecryptLastNameAsync(int id)    {        var connection = _context.Database.GetDbConnection();        await connection.OpenAsync();        try        {            using var command = connection.CreateCommand();            command.CommandText = """                SELECT convert_from(lastname, 'UTF8') AS DecryptedLastName                FROM ""Users""                WHERE ""UserID"" = @id;            """;            command.Parameters.Add(new NpgsqlParameter("@id", id));            var result = await command.ExecuteScalarAsync();            return result?.ToString();        }        finally        {            await connection.CloseAsync();        }    }    private static string GetSqlServerBackupPath()    {        var backupDir = Path.Combine(AppContext.BaseDirectory, "Backups");        if (!Directory.Exists(backupDir))            Directory.CreateDirectory(backupDir);        return backupDir;    }    private static string GenerateSecurePassword()    {        const string uppercase = "ABCDEFGHJKLMNOPQRSTUVWXYZ";        const string lowercase = "abcdefghijkmnopqrstuvwxyz";        const string digits = "0123456789";        const string special = "!@#$%^&*";        const string allChars = uppercase + lowercase + digits + special;        var password = new StringBuilder();        var random = new Random();        password.Append(uppercase[random.Next(uppercase.Length)]);        password.Append(lowercase[random.Next(lowercase.Length)]);        password.Append(digits[random.Next(digits.Length)]);        password.Append(special[random.Next(special.Length)]);        for (var i = password.Length; i < 16; i++)            password.Append(allChars[random.Next(allChars.Length)]);        var shuffled = password.ToString().ToCharArray();        for (var i = shuffled.Length - 1; i > 0; i--)        {            var j = random.Next(i + 1);            (shuffled[i], shuffled[j]) = (shuffled[j], shuffled[i]);        }        return new string(shuffled);    }    private static byte[] GenerateSalt()    {        var salt = new byte[32];        using var rng = RandomNumberGenerator.Create();        rng.GetBytes(salt);        return salt;    }    private static void CreatePasswordHash(string password, out string passwordHash, out string passwordSalt)    {        var saltBytes = GenerateSalt();        passwordSalt = Convert.ToBase64String(saltBytes);        using var sha = SHA512.Create();        var bytes = Encoding.UTF8.GetBytes(password + passwordSalt);        passwordHash = Convert.ToBase64String(sha.ComputeHash(bytes));    }}